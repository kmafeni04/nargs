require "string"
require "sequence"
require "os"
require "io"
require "memory"

local Variant = require "variant-nelua.variant"
local Sum = Variant.Sum

## local function mild_assert(cond, message)
  do
    if not #[cond]# then
      io.stderr:write(("\27[1m%s:%d: \27[31mmild assert\27[0m: %s\27[0m\n"):format(#[cond:location().srcname]#, #[cond:location().lineno]#, #[message or "assertion failed"]#))
      os.exit(1)
    end
  end
## end

local nargs = @record{}

-- NOTE: Should probably handle the length of expected argument values
local nargs.ParserOption = @record{
  long_name: string,
  short_name: string,
  desc: string,
  def: string,
  values: sequence(string),
}

local nargs.ParserFlag = @record{
  long_name: string,
  short_name: string,
  desc: string,
}

local nargs.ParserPosArg = @record{
  name: string,
  desc: string,
  def: string,
  value: string
}

local nargs.Parser = @record{
  name: string,
  desc: string,
  options: hashmap(string, nargs.ParserOption),
  flags: hashmap(string, nargs.ParserFlag),
  pos_args: sequence(nargs.ParserPosArg),
  cmds: hashmap(string, nargs.Parser),
  short_long: hashmap(string, string)
}

function nargs.new(name: string, desc: string): nargs.Parser
  if name == "" then
    name = #[srcloc.srcname]#
  end
  return {
    name = name,
    desc = desc
  }
end

## local function assert_name(name)
  local name = #[name]#
  ## static_assert(name, "Param `name` is required")
  mild_assert!(name ~= "")
  mild_assert!(not self.options:has(name), ("name '%s' has already been defined"):format(name))
  mild_assert!(not self.flags:has(name), ("name '%s' has already been defined"):format(name))
  for _, v in ipairs(self.pos_args) do
    mild_assert!(v.name ~= name, ("name '%s' has already been defined"):format(name))
  end
  mild_assert!(not self.cmds:has(name), ("name '%s' has already been defined"):format(name))
## end

function nargs.Parser:option(long_name: string, short_name: string, desc: string, def: string)
  assert_name!(long_name)
  self.options[long_name] = { long_name, short_name, desc, def }
  if short_name ~= "" then
    mild_assert!(not self.short_long:has(short_name), ("short_name '%s' has already been defined"):format(short_name))
    self.short_long[short_name] = long_name
  end
end

function nargs.Parser:flag(long_name: string, short_name: string, desc: string)
  assert_name!(long_name)
  self.flags[long_name] = { long_name, short_name, desc }
  if short_name ~= "" then
    mild_assert!(not self.short_long:has(short_name), ("short_name '%s' has already been defined"):format(short_name))
    self.short_long[short_name] = long_name
  end
end

function nargs.Parser:pos_arg(name: string, desc: string, def: string)
  assert_name!(name)
  self.pos_args:push({ name, desc, def })
end

function nargs.Parser:cmd(name: string, desc: string): *nargs.Parser
  assert_name!(name)
  self.cmds[name] = {
    name = name,
    desc = desc
  }
  return &self.cmds[name]
end

local nargs.ParsedCmdResult <forwarddecl> = @record{}

local nargs.ParsedResult = @Sum(record{
  opt: sequence(string),
  flag: boolean,
  pos_arg: string,
  cmd: hashmap(string, *nargs.ParsedCmdResult),
})

nargs.ParsedCmdResult = @record{
  res: nargs.ParsedResult
}

## local function parse(args, name, val, i)
  ## static_assert(args, "Param `args` is required")
  ## static_assert(name, "Param `name` is required")
  ## static_assert(val, "Param `val` is required")
  ## static_assert(i, "Param `i` is required")
  local args = #[args]#
  local name = #[name]#
  local val = #[val]#
  local i = #[i]#
  if self.options:has(name) then
    if val == "" then
      local err = ("Option '%s' expects an argument"):format(name)
      mild_assert!(#args > i + 1, err)
      mild_assert!(not args[i + 1]:match("^-"), err)
      val = args[i + 1]
      if not res:has(name) then
        res[name] = nargs.ParsedResult.opt({ val })
      else
        res[name]:get_opt():push(val)
      end
      i = i + 1
    end
  elseif self.flags:has(name) then
    mild_assert!(val == "", ("Flag '%s' does not take values"):format(name))
    res[name] = nargs.ParsedResult.flag(true)
  else
    mild_assert!(false, ("Unknown argument '%s'"):format(args[i]))
  end
## end

function nargs.Parser:parse(args: span(string)): (hashmap(string, nargs.ParsedResult), sequence(string))
  local res: hashmap(string, nargs.ParsedResult)
  local extras: sequence(string)
  local i = 0
  local pos_arg_len = 0
  while i < #args do
    if args[i]:match("^-") then
      -- Options & flags
      if args[i] == "--" then
        i = i + 1
        for index = i, <#args do
          extras:push(args[i])
        end
        break
      elseif args[i]:sub(1, 2) == "--" then
        local arg = args[i]
        local name = arg:sub(3)
        local val: string
        local matched, matched_seq = name:match("(.+)=(.+)")
        if matched then
          name = matched_seq[1]
          val = matched_seq[2]
        end
        parse!(args, name, val, i)
      else
        local arg = args[i]
        local name = arg:sub(2)
        local val: string
        local matched, matched_seq = name:match("(.+)=(.+)")
        if matched then
          name = matched_seq[1]
          val = matched_seq[2]
        end
        if #name > 1 then
          mild_assert!(val == "", ("Unexpected value '%s'"):format(val))
          for n in name:gmatch("%w") do
            local has, long_name = self.short_long:has_and_get(n)
            mild_assert!(has == true, ("Unknown option '-%s'"):format(n))
            parse!(args, long_name, val, i)
          end
        else
          local has, long_name = self.short_long:has_and_get(name)
          mild_assert!(has == true, ("Unknown option '-%s'"):format(name))
          parse!(args, long_name, val, i)
        end
      end
    elseif self.cmds:has(args[i]) then
      -- Commands
      local arg = args[i]
      i = i + 1
      local sub_args = args:sub(i, #args)
      local cmd_args = self.cmds[arg]:parse(sub_args)
      local cmd: hashmap(string, *nargs.ParsedCmdResult)
      for k, v in pairs(cmd_args) do
        -- NOTE: Remeber to document memory allocation
        local cmd_res: *nargs.ParsedCmdResult = new(nargs.ParsedCmdResult)
        local x: nargs.ParsedCmdResult = { v }
        memory.copy(cmd_res, &x, #nargs.ParsedCmdResult)
        cmd[k] = cmd_res
      end
      res[arg] = nargs.ParsedResult.cmd(cmd)
      break
    else
      -- Postional Arguments
      mild_assert!(pos_arg_len < #self.pos_args, ("Unknown argument '%s'"):format(args[i]))
      pos_arg_len = pos_arg_len + 1
      local pos_arg = self.pos_args[pos_arg_len]
      res[pos_arg.name] = nargs.ParsedResult.pos_arg(args[i])
    end
    i = i + 1
  end

  -- setting defaults
  for k, v in pairs(self.options) do
    if not res:has(k) then
      res[k] = nargs.ParsedResult.opt({ v.def })
    end
  end
  for k, v in pairs(self.flags) do
    if not res:has(k) then
      res[k] = nargs.ParsedResult.flag(false)
    end
  end
  for _, v in ipairs(self.pos_args) do
    if not res:has(v.name) then
      res[v.name] = nargs.ParsedResult.pos_arg(v.def)
    end
  end
  for k, v in pairs(self.cmds) do
    if not res:has(k) then
      res[k] = nargs.ParsedResult.cmd({})
    end
  end
  return res, extras
end

function nargs.destroy_args(args: hashmap(string, nargs.ParsedResult))
  for k, v in pairs(args) do
    if v:is_opt() then
      v:get_opt():destroy()
    elseif v:is_flag() then
      args[k] = nargs.ParsedResult.flag(false)
    elseif v:is_pos_arg() then
      args[k] = nargs.ParsedResult.pos_arg("")
    elseif v:is_cmd() then
      local cmd = v:get_cmd()
      for i, j in pairs(cmd) do
        if j then
          delete(j)
        end
      end
      cmd:destroy()
    end
  end
  args:destroy()
end

local parser = nargs.new()

require "arg"

parser:flag("world", "w")
parser:flag("we", "W")
parser:flag("help", "h")
parser:pos_arg("test", "", "123")

local first = parser:cmd("first")
first:flag("help", "h")
local second = first:cmd("second")
second:flag("test", "t")
second:flag("help", "h")

local args, extras = parser:parse(arg)

local world = args["world"]:get_flag()
print(world)

local we = args["we"]:get_flag()
print(we)

local help = args["help"]:get_flag()
print(help)

local test = args["test"]:get_pos_arg()
print(test)

local first = args["first"]:get_cmd()
local first_help = first["help"].res:get_flag()
print(first_help)
local second = first["second"].res:get_cmd()
local second_test = second["test"].res:get_flag()
print(second_test)

nargs.destroy_args(args)

-- return nargs
