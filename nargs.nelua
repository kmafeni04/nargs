-- TODO: Handle parser mutex groups
-- TRY: Improve sub command api

require "string"
require "sequence"
require "os"
require "io"
require "memory"

local Variant = require "variant-nelua.variant"
local Sum = Variant.Sum

## local function mild_assert(cond, message)
  do
    if not #[cond]# then
      io.stderr:write(("\27[1m%s:%d: \27[31mmild assert\27[0m: %s\27[0m\n"):format(#[cond:location().srcname]#, #[cond:location().lineno]#, #[message or "assertion failed"]#))
      os.exit(1)
    end
  end
## end

--- ### nargs
---`
local nargs = @record{}
---`

--- ### nargs.MAX_ARG_LEN
---`
local nargs.MAX_ARG_LEN: integer <const> = 9223372036854775807 -- INT64_MAX
---`

--- ### nargs.ParserOpt
---`
local nargs.ParserOpt = @record{
  long_name: string,
  short_name: string,
  placeholder: string,
  help: string,
  def: string,
  max_len: integer,
  values: sequence(string),
}
---`

--- ### nargs.ParserFlag
---`
local nargs.ParserFlag = @record{
  long_name: string,
  short_name: string,
  help: string,
}
---`

--- ### nargs.ParserPosArg
---`
local nargs.ParserPosArg = @record{
  name: string,
  help: string,
  def: string,
  max_len: integer,
  optional: boolean,
  values: sequence(string),
}
---`

--- ### nargs.Parser
---`
local nargs.Parser = @record{
  name: string,
  desc: string,
  help: string,
  opts: hashmap(string, nargs.ParserOpt),
  flags: hashmap(string, nargs.ParserFlag),
  pos_args: sequence(nargs.ParserPosArg),
  cmds: hashmap(string, nargs.Parser),
  short_long: hashmap(string, string)
}
---`

--- ### nargs.new
---`
function nargs.new(conf: nargs.Parser): nargs.Parser
---`
  if conf.name == "" then
    conf.name = #[srcloc.srcname]#
  end
  return conf
end

## local function assert_name(name)
  ## static_assert(name, "Param `name` is required")
  local name = #[name]#
  mild_assert!(name ~= "", "name cannot be an empty string")
  mild_assert!(name ~= "help", "name cannot be 'help'")
  mild_assert!(not self.opts:has(name), ("name '%s' has already been defined"):format(name))
  mild_assert!(not self.flags:has(name), ("name '%s' has already been defined"):format(name))
  for _, v in ipairs(self.pos_args) do
    mild_assert!(v.name ~= name, ("name '%s' has already been defined"):format(name))
  end
  mild_assert!(not self.cmds:has(name), ("name '%s' has already been defined"):format(name))
## end

--- ### nargs.Parser:opt
---`
function nargs.Parser:opt(conf: nargs.ParserOpt)
---`
  conf.long_name = conf.long_name:gsub("^%-%-", "")
  assert_name!(conf.long_name)
  if conf.max_len <= 0 then conf.max_len = 1 else conf.max_len = conf.max_len end
  self.opts[conf.long_name] = conf
  if conf.short_name ~= "" then
    conf.short_name = conf.short_name:gsub("^%-", "")
    mild_assert!(conf.short_name ~= "h", "short_name cannot be 'h'")
    mild_assert!(not self.short_long:has(conf.short_name), ("short_name '%s' has already been defined"):format(conf.short_name))
    self.short_long[conf.short_name] = conf.long_name
  end
end

--- ### nargs.Parser:flag
---`
function nargs.Parser:flag(conf: nargs.ParserFlag)
---`
  conf.long_name = conf.long_name:gsub("^%-%-", "")
  assert_name!(conf.long_name)
  self.flags[conf.long_name] = conf
  if conf.short_name ~= "" then
    conf.short_name = conf.short_name:gsub("^%-", "")
    mild_assert!(conf.short_name ~= "h", "short_name cannot be 'h'")
    mild_assert!(not self.short_long:has(conf.short_name), ("short_name '%s' has already been defined"):format(conf.short_name))
    self.short_long[conf.short_name] = conf.long_name
  end
end

--- ### nargs.Parser:pos_arg
---`
function nargs.Parser:pos_arg(conf: nargs.ParserPosArg)
---`
  assert_name!(conf.name)
  if conf.max_len <= 0 then conf.max_len = 1 else conf.max_len = conf.max_len end
  self.pos_args:push(conf)
end

--- ### nargs.Parser:cmd
---`
function nargs.Parser:cmd(conf: nargs.Parser): *nargs.Parser
---`
  assert_name!(conf.name)
  self.cmds[conf.name] = conf
  return &self.cmds[conf.name]
end

local nargs.ParsedCmdResult <forwarddecl> = @record{}

--- ### nargs.ParsedResult
---`
local nargs.ParsedResult = @Sum(record{
  opt: sequence(string),
  flag: boolean,
  pos_arg: sequence(string),
  cmd: hashmap(string, *nargs.ParsedCmdResult),
})
---`

--- ### nargs.ParsedCmdResult
---`
nargs.ParsedCmdResult = @record{
  res: nargs.ParsedResult
}
---`

## local function parse_option_or_arg(args, name, val, i)
  ## static_assert(args, "Param `args` is required")
  ## static_assert(name, "Param `name` is required")
  ## static_assert(val, "Param `val` is required")
  ## static_assert(i, "Param `i` is required")
  local _args = #[args]#
  local _name = #[name]#
  local _val = #[val]#
  local _i = #[i]#
  if self.opts:has(_name) then
    if _val == "" then
      local err = ("Option '%s' expects an argument"):format(_name)
      mild_assert!(#_args > _i + 1, err)
      mild_assert!(not _args[_i + 1]:match("^-"), err)
      _val = _args[_i + 1]
      _i = _i + 1
    end
    if not res:has(_name) then
      res[_name] = nargs.ParsedResult.opt({ _val })
    else
      local opt = res[_name]:get_opt()
      mild_assert!(#opt <= self.opts[_name].max_len, ("Too many values for Option '%s'"):format(_name))
      opt:push(_val)
    end
  elseif self.flags:has(_name) then
    mild_assert!(_val == "", ("Flag '%s' does not take values"):format(_name))
    res[_name] = nargs.ParsedResult.flag(true)
  else
    mild_assert!(false, ("Unknown argument '%s'"):format(_args[_i]))
  end
  #|args.name|# = _args
  #|name.name|# = _name
  #|val.name|# = _val
  #|i.name|# = _i
## end

--- ### nargs.Parser:get_help
---`
function nargs.Parser:get_help(): string
---`
  local sb: stringbuilder
  local col_len = #("-h, --help")
  sb:writef("Usage: %s [-h]", self.name)
  for _, opt in pairs(self.opts) do
    sb:writef(" [")
    local len: integer
    if opt.short_name ~= "" then
      len = #("-") + #opt.short_name + #(", ") + #("--") + #opt.long_name
      sb:writef("-%s", opt.short_name)
    else
      len = #("--") + #opt.long_name
      sb:writef("--%s", opt.long_name)
    end
    if opt.placeholder ~= "" then
      len = len + #(" ") + #opt.placeholder
      sb:writef(" %s", opt.placeholder)
    end
    if len > col_len then col_len = len end
    sb:writef("]")
  end
  for _, flag in pairs(self.flags) do
    local len: integer
    sb:writef(" [")
    if flag.short_name ~= "" then
      len = #flag.short_name + #(", ") + #flag.long_name
      sb:writef("-%s", flag.short_name)
    else
      len = #flag.long_name
      sb:writef("--%s", flag.long_name)
    end
    if len > col_len then col_len = len end
    sb:writef("]")
  end
  if #self.cmds > 0 then
    sb:write(" <command>")
    for _, cmd in pairs(self.cmds) do
      local len: integer
      len = #cmd.name
      if len > col_len then col_len = len end
    end
  end
  for _, pos_arg in ipairs(self.pos_args) do
    local len: integer
    len = #pos_arg.name
    if len > col_len then col_len = len end
    sb:write(" ")
    sb:write(pos_arg.optional and "[" or "<")
    sb:write(pos_arg.name)
    sb:write(pos_arg.optional and "]" or ">")
  end
  sb:write(" ...\n\n")
  if self.desc ~= "" then
    sb:writef("%s\n\n", self.desc)
  end

  if #self.pos_args > 0 then
    sb:write("Aguments:\n")
    for _, pos_arg in ipairs(self.pos_args) do
      sb:writef("  %s", pos_arg.name)
      sb:writef(" %s%s", string.rep(" ", col_len - #pos_arg.name), pos_arg.help)
      sb:write("\n")
    end
    sb:write("\n")
  end

  if #self.opts > 0 then
    sb:write("Options:\n")
    for _, opt in pairs(self.opts) do
      sb:write("  ")
      local len: integer
      if opt.short_name ~= "" then
        local s = ("-%s, --%s"):format(opt.short_name, opt.long_name)
        sb:write(s)
        len = #s
      else
        local s = ("--%s"):format(opt.long_name)
        sb:writef(s)
        len = #s
      end
      if opt.placeholder ~= "" then
        len = len + #(" ") + #opt.placeholder
        sb:writef(" %s", opt.placeholder)
      end
      sb:writef(" %s%s", string.rep(" ", col_len - len), opt.help)
      sb:write("\n")
    end
    sb:write("\n")
  end

  if #self.flags > 0 then
    sb:write("Flags:\n")
    for _, flag in pairs(self.flags) do
      sb:write("  ")
      local len: integer
      if flag.short_name ~= "" then
        local s = ("-%s, --%s"):format(flag.short_name, flag.long_name)
        sb:write(s)
        len = #s
      else
        local s = ("--%s"):format(flag.long_name)
        sb:writef(s)
        len = #s
      end
      sb:writef(" %s%s", string.rep(" ", col_len - len), flag.help)
      sb:write("\n")
    end
    sb:write("\n")
  end

  if #self.cmds > 0 then
    sb:write("Commands:\n")
    for _, cmd in pairs(self.cmds) do
      sb:writef("  %s", cmd.name)
      sb:writef(" %s%s", string.rep(" ", col_len - #cmd.name), cmd.help)
      sb:write("\n")
    end
    sb:write("\n")
  end
  sb:rollback(1)

  return sb:promote()
end

--- ### nargs.Parser:print_help
---`
function nargs.Parser:print_help()
---`
  io.write(self:get_help())
end

--- ### nargs.Parser:parse
---`
function nargs.Parser:parse(args: span(string)): (hashmap(string, nargs.ParsedResult), sequence(string))
---`
  local res: hashmap(string, nargs.ParsedResult)
  local extras: sequence(string)
  local i = 0
  local pos_args_count = 0
  while i < #args do
    if args[i]:match("^-") then
      -- Options & flags
      if args[i] == "--" then
        i = i + 1
        for index = i, <#args do
          extras:push(args[i])
        end
        break
      elseif args[i] == "-h" or args[i] == "--help" then
        self:print_help()
        os.exit(0)
      elseif args[i]:sub(1, 2) == "--" then
        local arg = args[i]
        local name = arg:sub(3)
        local val: string
        local matched, matched_seq = name:match("(.+)=(.+)")
        if matched then
          name = matched_seq[1]
          val = matched_seq[2]
        end
        parse_option_or_arg!(args, name, val, i)
      else
        local arg = args[i]
        local name = arg:sub(2)
        local val: string
        local matched, matched_seq = name:match("(.+)=(.+)")
        if matched then
          name = matched_seq[1]
          val = matched_seq[2]
        end
        if #name > 1 then
          mild_assert!(val == "", ("Unexpected value '%s'"):format(val))
          for n in name:gmatch("%w") do
            local has, long_name = self.short_long:has_and_get(n)
            mild_assert!(has == true, ("Unknown option '-%s'"):format(n))
            parse_option_or_arg!(args, long_name, val, i)
          end
        else
          local has, long_name = self.short_long:has_and_get(name)
          mild_assert!(has == true, ("Unknown option '-%s'"):format(name))
          parse_option_or_arg!(args, long_name, val, i)
        end
      end
    elseif self.cmds:has(args[i]) then
      -- Commands
      local arg = args[i]
      i = i + 1
      local sub_args = args:sub(i, #args)
      local cmd_args = self.cmds[arg]:parse(sub_args)
      local cmd: hashmap(string, *nargs.ParsedCmdResult)
      for k, v in pairs(cmd_args) do
        -- NOTE: Remeber to document memory allocation
        local cmd_res: *nargs.ParsedCmdResult = new(nargs.ParsedCmdResult)
        local x: nargs.ParsedCmdResult = { v }
        memory.copy(cmd_res, &x, #nargs.ParsedCmdResult)
        cmd[k] = cmd_res
      end
      res[arg] = nargs.ParsedResult.cmd(cmd)
      break
    else
      -- Positional Arguments
      mild_assert!(pos_args_count < #self.pos_args, ("Unknown argument '%s'"):format(args[i]))
      pos_args_count = pos_args_count + 1
      local pos_arg = self.pos_args[pos_args_count]
      for pos_arg_len = 0, pos_arg.max_len do
        if i >= #args or args[i]:match("^%-") then i = i - 1 break end
        if not res:has(pos_arg.name) then
          res[pos_arg.name] = nargs.ParsedResult.pos_arg({ args[i] })
        else
          res[pos_arg.name]:get_pos_arg():push(args[i])
        end
        i = i + 1
      end
    end
    i = i + 1
  end

  -- Setting defaults
  for k, v in pairs(self.opts) do
    if not res:has(k) then
      res[k] = nargs.ParsedResult.opt({ v.def })
    end
  end
  for k, v in pairs(self.flags) do
    if not res:has(k) then
      res[k] = nargs.ParsedResult.flag(false)
    end
  end
  for _, v in ipairs(self.pos_args) do
    if not res:has(v.name) then
      res[v.name] = nargs.ParsedResult.pos_arg({ v.def })
    end
  end
  for k, v in pairs(self.cmds) do
    if not res:has(k) then
      res[k] = nargs.ParsedResult.cmd({})
    end
  end
  return res, extras
end

--- ### nargs.destroy_args
---`
function nargs.destroy_args(args: hashmap(string, nargs.ParsedResult))
---`
  for k, v in pairs(args) do
    if v:is_opt() then
      v:get_opt():destroy()
    elseif v:is_flag() then
      args[k] = nargs.ParsedResult.flag(false)
    elseif v:is_pos_arg() then
      args[k]:get_pos_arg():destroy()
    elseif v:is_cmd() then
      local cmd = v:get_cmd()
      for i, j in pairs(cmd) do
        if j then
          delete(j)
        end
      end
      cmd:destroy()
    end
  end
  args:destroy()
end

return nargs
