-- TODO: Handle printing help
-- TRY: Improve sub command api

require "string"
require "sequence"
require "os"
require "io"
require "memory"

local Variant = require "variant-nelua.variant"
local Sum = Variant.Sum

## local function mild_assert(cond, message)
  do
    if not #[cond]# then
      io.stderr:write(("\27[1m%s:%d: \27[31mmild assert\27[0m: %s\27[0m\n"):format(#[cond:location().srcname]#, #[cond:location().lineno]#, #[message or "assertion failed"]#))
      os.exit(1)
    end
  end
## end

--- ### nargs
---`
local nargs = @record{}
---`

--- ### nargs.MAX_ARG_LEN
---`
local nargs.MAX_ARG_LEN: integer <const> = 9223372036854775807 -- INT64_MAX
---`

--- ### nargs.ParserOption
---`
local nargs.ParserOption = @record{
  long_name: string,
  short_name: string,
  desc: string,
  def: string,
  max_len: integer,
  values: sequence(string),
}
---`

--- ### nargs.ParserFlag
---`
local nargs.ParserFlag = @record{
  long_name: string,
  short_name: string,
  desc: string,
}
---`

--- ### nargs.ParserPosArg
---`
local nargs.ParserPosArg = @record{
  name: string,
  desc: string,
  def: string,
  max_len: integer,
  values: sequence(string),
}
---`

--- ### nargs.Parser
---`
local nargs.Parser = @record{
  name: string,
  desc: string,
  options: hashmap(string, nargs.ParserOption),
  flags: hashmap(string, nargs.ParserFlag),
  pos_args: sequence(nargs.ParserPosArg),
  cmds: hashmap(string, nargs.Parser),
  short_long: hashmap(string, string)
}
---`

--- ### nargs.new
---`
function nargs.new(name: string, desc: string): nargs.Parser
---`
  if name == "" then
    name = #[srcloc.srcname]#
  end
  return {
    name = name,
    desc = desc
  }
end

## local function assert_name(name)
  ## static_assert(name, "Param `name` is required")
  local name = #[name]#
  mild_assert!(name ~= "")
  mild_assert!(not self.options:has(name), ("name '%s' has already been defined"):format(name))
  mild_assert!(not self.flags:has(name), ("name '%s' has already been defined"):format(name))
  for _, v in ipairs(self.pos_args) do
    mild_assert!(v.name ~= name, ("name '%s' has already been defined"):format(name))
  end
  mild_assert!(not self.cmds:has(name), ("name '%s' has already been defined"):format(name))
## end

--- ### nargs.Parser:opt
---`
function nargs.Parser:opt(long_name: string, short_name: string, desc: string, def: string, max_len: integer)
---`
  long_name = long_name:gsub("^%-%-", "")
  if max_len <= 0 then max_len = 1 else max_len = max_len end
  self.options[long_name] = { long_name, short_name, desc, def, max_len }
  if short_name ~= "" then
    short_name = short_name:gsub("^%-", "")
    mild_assert!(not self.short_long:has(short_name), ("short_name '%s' has already been defined"):format(short_name))
    self.short_long[short_name] = long_name
  end
end

--- ### nargs.Parser:flag
---`
function nargs.Parser:flag(long_name: string, short_name: string, desc: string)
---`
  long_name = long_name:gsub("^%-%-", "")
  assert_name!(long_name)
  self.flags[long_name] = { long_name, short_name, desc }
  if short_name ~= "" then
    short_name = short_name:gsub("^%-", "")
    mild_assert!(not self.short_long:has(short_name), ("short_name '%s' has already been defined"):format(short_name))
    self.short_long[short_name] = long_name
  end
end

--- ### nargs.Parser:pos_arg
---`
function nargs.Parser:pos_arg(name: string, desc: string, def: string, max_len: integer)
---`
  assert_name!(name)
  if max_len <= 0 then max_len = 1 else max_len = max_len end
  self.pos_args:push({ name, desc, def, max_len })
end

--- ### nargs.Parser:cmd
---`
function nargs.Parser:cmd(name: string, desc: string): *nargs.Parser
---`
  assert_name!(name)
  self.cmds[name] = {
    name = name,
    desc = desc
  }
  return &self.cmds[name]
end

local nargs.ParsedCmdResult <forwarddecl> = @record{}

--- ### nargs.ParsedResult
---`
local nargs.ParsedResult = @Sum(record{
  opt: sequence(string),
  flag: boolean,
  pos_arg: sequence(string),
  cmd: hashmap(string, *nargs.ParsedCmdResult),
})
---`

--- ### nargs.ParsedCmdResult
---`
nargs.ParsedCmdResult = @record{
  res: nargs.ParsedResult
}
---`

## local function parse_option_or_arg(args, name, val, i)
  ## static_assert(args, "Param `args` is required")
  ## static_assert(name, "Param `name` is required")
  ## static_assert(val, "Param `val` is required")
  ## static_assert(i, "Param `i` is required")
  local _args = #[args]#
  local _name = #[name]#
  local _val = #[val]#
  local _i = #[i]#
  if self.options:has(_name) then
    if _val == "" then
      local err = ("Option '%s' expects an argument"):format(_name)
      mild_assert!(#_args > _i + 1, err)
      mild_assert!(not _args[_i + 1]:match("^-"), err)
      _val = _args[_i + 1]
      _i = _i + 1
    end
    if not res:has(_name) then
      res[_name] = nargs.ParsedResult.opt({ _val })
    else
      local opt = res[_name]:get_opt()
      mild_assert!(#opt <= self.options[_name].max_len, ("Too many values for Option '%s'"):format(_name))
      opt:push(_val)
    end
  elseif self.flags:has(_name) then
    mild_assert!(_val == "", ("Flag '%s' does not take values"):format(_name))
    res[_name] = nargs.ParsedResult.flag(true)
  else
    mild_assert!(false, ("Unknown argument '%s'"):format(_args[_i]))
  end
  #|args.name|# = _args
  #|name.name|# = _name
  #|val.name|# = _val
  #|i.name|# = _i
## end

--- ### nargs.Parser:parse
---`
function nargs.Parser:parse(args: span(string)): (hashmap(string, nargs.ParsedResult), sequence(string))
---`
  local res: hashmap(string, nargs.ParsedResult)
  local extras: sequence(string)
  local i = 0
  local pos_args_count = 0
  while i < #args do
    if args[i]:match("^-") then
      -- Options & flags
      if args[i] == "--" then
        i = i + 1
        for index = i, <#args do
          extras:push(args[i])
        end
        break
      elseif args[i]:sub(1, 2) == "--" then
        local arg = args[i]
        local name = arg:sub(3)
        local val: string
        local matched, matched_seq = name:match("(.+)=(.+)")
        if matched then
          name = matched_seq[1]
          val = matched_seq[2]
        end
        parse_option_or_arg!(args, name, val, i)
      else
        local arg = args[i]
        local name = arg:sub(2)
        local val: string
        local matched, matched_seq = name:match("(.+)=(.+)")
        if matched then
          name = matched_seq[1]
          val = matched_seq[2]
        end
        if #name > 1 then
          mild_assert!(val == "", ("Unexpected value '%s'"):format(val))
          for n in name:gmatch("%w") do
            local has, long_name = self.short_long:has_and_get(n)
            mild_assert!(has == true, ("Unknown option '-%s'"):format(n))
            parse_option_or_arg!(args, long_name, val, i)
          end
        else
          local has, long_name = self.short_long:has_and_get(name)
          mild_assert!(has == true, ("Unknown option '-%s'"):format(name))
          parse_option_or_arg!(args, long_name, val, i)
        end
      end
    elseif self.cmds:has(args[i]) then
      -- Commands
      local arg = args[i]
      i = i + 1
      local sub_args = args:sub(i, #args)
      local cmd_args = self.cmds[arg]:parse(sub_args)
      local cmd: hashmap(string, *nargs.ParsedCmdResult)
      for k, v in pairs(cmd_args) do
        -- NOTE: Remeber to document memory allocation
        local cmd_res: *nargs.ParsedCmdResult = new(nargs.ParsedCmdResult)
        local x: nargs.ParsedCmdResult = { v }
        memory.copy(cmd_res, &x, #nargs.ParsedCmdResult)
        cmd[k] = cmd_res
      end
      res[arg] = nargs.ParsedResult.cmd(cmd)
      break
    else
      -- Positional Arguments
      mild_assert!(pos_args_count < #self.pos_args, ("Unknown argument '%s'"):format(args[i]))
      pos_args_count = pos_args_count + 1
      local pos_arg = self.pos_args[pos_args_count]
      for pos_arg_len = 0, pos_arg.max_len do
        if i >= #args or args[i]:match("^%-") then i = i - 1 break end
        if not res:has(pos_arg.name) then
          res[pos_arg.name] = nargs.ParsedResult.pos_arg({ args[i] })
        else
          res[pos_arg.name]:get_pos_arg():push(args[i])
        end
        i = i + 1
      end
    end
    i = i + 1
  end

  -- Setting defaults
  for k, v in pairs(self.options) do
    if not res:has(k) then
      res[k] = nargs.ParsedResult.opt({ v.def })
    end
  end
  for k, v in pairs(self.flags) do
    if not res:has(k) then
      res[k] = nargs.ParsedResult.flag(false)
    end
  end
  for _, v in ipairs(self.pos_args) do
    if not res:has(v.name) then
      res[v.name] = nargs.ParsedResult.pos_arg({ v.def })
    end
  end
  for k, v in pairs(self.cmds) do
    if not res:has(k) then
      res[k] = nargs.ParsedResult.cmd({})
    end
  end
  return res, extras
end

--- ### nargs.destroy_args
---`
function nargs.destroy_args(args: hashmap(string, nargs.ParsedResult))
---`
  for k, v in pairs(args) do
    if v:is_opt() then
      v:get_opt():destroy()
    elseif v:is_flag() then
      args[k] = nargs.ParsedResult.flag(false)
    elseif v:is_pos_arg() then
      args[k]:get_pos_arg():destroy()
    elseif v:is_cmd() then
      local cmd = v:get_cmd()
      for i, j in pairs(cmd) do
        if j then
          delete(j)
        end
      end
      cmd:destroy()
    end
  end
  args:destroy()
end

return nargs
